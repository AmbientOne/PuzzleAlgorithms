# Solving the 8-puzzle using A*


# In order to create the search space/frontier, how do we store the search space

# Tree with nodes representing initial state and possibly places to move the empty space (0)
# Operations for moving the empty space is Up, Down, Left, Right


# Solving the Algorithm

# A* algorithm uses something called the f-score = h-score + g-score
# The h-score = number of misplaces tiles compared to the goal state
# The g-score = number of states traveled since the start node to the current node


# When new states are generated by moving the empty space, we push the current node into a traversed array
# Each new state is given a f-score and we choose our currentNode = lowest(f-score) state


### Node class

goal_state = []
import copy

class Node:

    # Constructor
    def __init__(self, data, parent, cost):
        self.data = data
        self.parent = parent
        self.cost = cost

    # Operations on currentNode and generate its leaf nodes
    def operations(self):
        # Empty space is = 0
        # If data is stored as nested list:
        #               012345678, its 2d version =   012
        #                                            345
        #                                            678
        # Map to find out which each one can go:
        # x,y - position[0] = (0,0), position[1] = (0,1), position[2] = (0,2),
        #       position[3] = (1,0), position[4] = (1,1), position[5] = (1,2),
        #       position[6] = (2,0), position[7] = (2,1), position[8] = (2,2)

        # Find x and y of the current empty space:
        x = 0
        y = 0
        for i in self.data:
            for j in self.data[i]:
                if self.data[i][j] == 0:
                    x = i
                    y = j
        # Possible operations
        #up, down, left, right

        for i in possibleMoves:
            # Check to see if possible

            if


class Puzzle:
    def move_up(self, data):


